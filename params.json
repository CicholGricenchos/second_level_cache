{"name":"Second level cache","tagline":"Write Through and Read Through caching library inspired by CacheMoney and cache_fu, support ActiveRecord 4.","body":"# SecondLevelCache\r\n\r\n[![Gem Version](https://badge.fury.io/rb/second_level_cache.png)](http://badge.fury.io/rb/second_level_cache)\r\n[![Dependency Status](https://gemnasium.com/hooopo/second_level_cache.png)](https://gemnasium.com/hooopo/second_level_cache)\r\n[![Build Status](https://travis-ci.org/hooopo/second_level_cache.png?branch=master)](https://travis-ci.org/hooopo/second_level_cache)\r\n[![Code Climate](https://codeclimate.com/github/hooopo/second_level_cache.png)](https://codeclimate.com/github/hooopo/second_level_cache)\r\n\r\nSecondLevelCache is a write-through and read-through caching library inspired by Cache Money and cache_fu, support ActiveRecord 4.\r\n\r\nRead-Through: Queries by ID, like `current_user.articles.find(params[:id])`, will first look in cache store and then look in the database for the results of that query. If there is a cache miss, it will populate the cache.\r\n\r\nWrite-Through: As objects are created, updated, and deleted, all of the caches are automatically kept up-to-date and coherent.\r\n\r\n\r\n## Install\r\n\r\nIn your gem file:\r\n\r\n```ruby\r\ngem \"second_level_cache\", \"~> 2.0.0.rc1\"\r\n```\r\n\r\n## Usage\r\n\r\nFor example, cache User objects:\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n  acts_as_cached(:version => 1, :expires_in => 1.week)\r\nend\r\n```\r\n\r\nThen it will fetch cached object in this situations:\r\n\r\n```ruby\r\nUser.find(1)\r\nuser.articles.find(1)\r\nUser.where(:status => 1).find(1)\r\narticle.user\r\n```\r\n\r\nCache key:\r\n\r\n```ruby\r\nuser = User.find 1\r\nuser.second_level_cache_key  # We will get the key looks like \"slc/user/1/0\"\r\n```\r\n\r\nExpires cache:\r\n\r\n```ruby\r\nuser = User.find(1)\r\nuser.expire_second_level_cache\r\n```\r\nor expires cache using class method:\r\n```ruby\r\nUser.expire_second_level_cache(1)\r\n```\r\n\r\nDisable SecondLevelCache:\r\n\r\n```ruby\r\nUser.without_second_level_cache do\r\n  user = User.find 1\r\n  # ...\r\nend\r\n```\r\n\r\nOnly `SELECT *` query will be cached:\r\n\r\n```ruby\r\n# this query will NOT be cached\r\nUser.select(\"id, name\").find(1)\r\n```\r\n\r\nNotice:\r\n\r\n* SecondLevelCache cache by model name and id, so only find_one query will work.\r\n* Only equal conditions query WILL get cache; and SQL string query like `User.where(\"name = 'Hooopo'\").find(1)` WILL NOT work.\r\n* SecondLevelCache sync cache after transaction commit:\r\n\r\n```ruby\r\n# user and account's write_second_level_cache operation will invoke after the logger.\r\nActiveRecord::Base.transaction do\r\n   user.save\r\n   account.save\r\n   Rails.logger.info \"info\"\r\nend # <- Cache write \r\n\r\n# if you want to do something after user and account's write_second_level_cache operation, do this way:\r\nActiveRecord::Base.transaction do\r\n   user.save\r\n   account.save\r\nend # <- Cache write \r\nRails.logger.info \"info\"\r\n```\r\n\r\n## Configure\r\n\r\nIn production env, we recommend to use [Dalli](https://github.com/mperham/dalli) as Rails cache store.\r\n```ruby\r\n config.cache_store = [:dalli_store, APP_CONFIG[\"memcached_host\"], {:namespace => \"ns\", :compress => true}]\r\n```\r\n\r\n## Tips: \r\n\r\n* When you want to clear only second level cache apart from other cache for example fragment cache in cache store,\r\nyou can only change the `cache_key_prefix`:\r\n\r\n```ruby\r\nSecondLevelCache.configure.cache_key_prefix = \"slc1\"\r\n```\r\n* When schema of your model changed, just change the `version` of the speical model, avoding clear all the cache.\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n  acts_as_cached(:version => 2, :expires_in => 1.week)\r\nend\r\n```\r\n\r\n* It provides a great feature, not hits db when fetching record via unique key(not primary key). \r\n\r\n```ruby\r\n# this will fetch from cache\r\nuser = User.fetch_by_uniq_key(\"hooopo\", :nick_name)\r\n\r\n# this also fetch from cache\r\nuser = User.fetch_by_uniq_key!(\"hooopo\", :nick_name) # this will raise `ActiveRecord::RecordNotFound` Exception when nick name not exists.\r\n```\r\n\r\n* You can use Rails's [Eager Loading](http://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations) feature as normal. Even better, second_level_cache will transform the `IN` query into a Rails.cache.multi_read operation. For example:\r\n\r\n```ruby\r\nAnswer.includes(:question).limit(10).order(\"id DESC\").each{|answer| answer.question.title}\r\nAnswer Load (0.2ms)  SELECT `answers`.* FROM `answers` ORDER BY id DESC LIMIT 10 # Only one SQL query and one Rails.cache.read_multi fetching operation.\r\n```\r\n[Details for read_multi feature](http://hooopo.writings.io/articles/a9cae5e0).\r\n\r\n## Contributors\r\n\r\n* [chloerei](https://github.com/chloerei)\r\n* [reyesyang](https://github.com/reyesyang)\r\n* [hooopo](https://github.com/hooopo)\r\n* [sishen](https://github.com/sishen)\r\n\r\n## License\r\n\r\nMIT License\r\n\r\n## Donate\r\n\r\nIf you find my work useful and you want to encourage the development of more free resources, you can do it by donating...\r\n[![alipay](http://style.neoease.org/doc/donate-with-alipay.png)](https://me.alipay.com/hooopo)","google":"UA-40399330-1","note":"Don't delete this file! It's used internally to help with page regeneration."}